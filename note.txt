NIO（New IO）
NIO 是从 Java 1.4 版本开始引入的一个新的 IO API，可以替代标准的 IO API。
NIO 与原来的 IO 有同样的作用和目的，但是使用的方式完全不同，NIO 是面向缓冲区的、基于通道的 IO 操作。
NIO 将以更加高效的方式进行文件的读写操作。

IO 与 NIO 的区别
IO							NIO
面向流（Stream Oriented）		面向缓冲区（Buffer Oriented）
阻塞IO（Blocking IO）		非阻塞IO（Non Blocking IO）
（无）						选择器（Selectors）

===================================================================

通道（Channel）和缓冲区（Buffer）

NIO 的核心在于通道（Channel）和缓冲区（Buffer）
通道表示打开到 IO 设备（例如：文件、套接字）的连接
若要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区
然后操作缓冲区，对数据进行处理

简而言之，Channel 负责传输，Buffer 负责存储

===================================================================

缓冲区（Buffer）

直接与非直接缓冲区

如果是直接字节缓冲区，则虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作，
也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），
虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。

直接字节缓冲区可以通过调用此类的 allocateDirect() 工厂方法来创建。
此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。
直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。
所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。
一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。

直接字节缓冲区还可以通过 FileChannel 的 map() 方法 将文件区域直接映射到内存中来创建。
该方法返回 MappedByteBuffer。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。
如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，
并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。

===================================================================

阻塞与非阻塞

传统的 IO 流都是阻塞式的。也就是说，当一个线程调用 read() 或 write() 时，
该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。
因此，在完成网络通信进行 IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，
当服务器端需要处理大量客户端时，性能急剧下降。

NIO 是非阻塞式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。
线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。
因此，NIO 可以让服务器端使用一个或几个线程来同时处理连接到服务器端的所有客户端。

===================================================================

选择器（Selector）

选择器（Selector）是 SelectableChannel 的多路复用器，
可以同时监控多个 SelectableChannel 的 IO 状况，
使用 Selector 可使一个单独的线程管理多个 Channel。
Selector 是非阻塞 IO 的核心。

调用 SelectableChannel.register(Selector sel, int ops) 将通道注册到选择器。

可以监听的事件类型
SelectionKey.OP_READ	（1）	读
SelectionKey.OP_WRITE	（4）	写
SelectionKey.OP_CONNECT	（8）	连接
SelectionKey.OP_ACCEPT	（16）	接收

若监听多个事件，则可以使用“位或”操作符连接。
